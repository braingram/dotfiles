# -*- coding: utf-8 -*-

"""
dotfiles.core
~~~~~~~~~~~~~

This module provides the basic functionality of dotfiles.
"""

import fnmatch
import os
import shutil
import subprocess
import tempfile


__version__ = '0.5.2'
__author__ = 'Jon Bernard'
__license__ = 'ISC'


def tree(dir):
    """
    Make a tree dictionary from a directory. Where...
        Keys = directories & subdirectories
        Values = Files in those subdirectories
    """
    t = {}
    prefix = os.path.split(dir.rstrip(' /'))[0]
    for d, _, f in os.walk(dir):
        t[os.path.relpath(d, prefix)] = f
    return prefix, t


def merge_trees(target, name):
    """
    Take a dotfile tracked directory (target) and an existing directory (name).
    Combine the two in a 'safe' way..

    1) find all files in name that are not in target
        these are 'ignored' files
    2) move these 'ignored' files to a safe place (tmp directory)
    3) add 'ignored' files and .gitignore to a .gitignore file
    4) remove existing directory name
    5) symlink target to name
    6) move 'ignored' files and .gitignore back in place
    7) remove temporary directory
    """
    # move existing files to a 'save' place
    tmp = tempfile.mkdtemp('dotfiles')
    shutil.move(name, tmp)

    # symlink target to name
    os.symlink(target, name)

    # old
    old = tmp + '/' + os.path.split(name.rstrip(' /'))[-1]
    oprefix, otree = tree(old)
    nprefix, ntree = tree(name)
    #print "Old prefix:", oprefix
    #print "New prefix:", nprefix

    old_files = ['.gitignore', ]
    #print "Old subdirs:", otree.keys()
    for d in otree.keys():
        if d in ntree.keys():  # new and old both have dir
            # check files
            for f in otree[d]:
                if f in ntree[d]:
                    # file was in old tree AND in new
                    print "Discarding old file: %s" % \
                            os.path.join(nprefix, d, f)
                    # TODO: merge files
                else:
                    # file was in old tree NOT new
                    shutil.move(os.path.join(oprefix, d, f), \
                            os.path.join(nprefix, d, f))
                    fn = os.path.join(d, f)
                    fn = os.path.join(*fn.split(os.path.sep)[1:])
                    old_files.append(fn)
        else:
            # dir only in old
            shutil.move(os.path.join(oprefix, d), \
                    os.path.join(nprefix, d))
            fn = d.rsplit(' /')
            fn = os.path.join(*fn.split(os.path.sep)[1:])
            old_files.append(os.path.join(d, '*'))
    #print "Old files:", old_files

    # make appropriate .gitignore
    #print "Writing to:", os.path.join(target, '.gitignore')
    with open(os.path.join(target, '.gitignore'), 'a') as ignore_file:
        ignore_file.write("# generated by dotfiles\n")
        [ignore_file.write(fn + "\n") for fn in old_files]

    shutil.rmtree(tmp)


class Dotfile(object):

    def __init__(self, name, target, home):
        if name.startswith('/'):
            self.name = name
        else:
            self.name = home + '/.%s' % name.strip('.')
        self.basename = os.path.basename(self.name)
        self.target = target.rstrip('/')
        self.status = ''
        if not os.path.lexists(self.name):
            self.status = 'missing'
        elif os.path.realpath(self.name) != self.target:
            self.status = 'unsynced'

    def sync(self, force):
        if self.status == 'missing':
            os.symlink(self.target, self.name)
        elif self.status == 'unsynced':
            if not force:
                print "Skipping \"%s\", use --force to override" % \
                self.basename
                return
            if os.path.isdir(self.name) and not os.path.islink(self.name):
                print "Merging trees"
                merge_trees(self.target, self.name)
                #shutil.rmtree(self.name)
            else:
                os.remove(self.name)
                os.symlink(self.target, self.name)

    def add(self):
        if self.status == 'missing':
            print "Skipping \"%s\", file not found" % self.basename
            return
        if self.status == '':
            print "Skipping \"%s\", already managed" % self.basename
            return
        shutil.move(self.name, self.target)
        os.symlink(self.target, self.name)

    def remove(self):
        if self.status != '':
            print "Skipping \"%s\", file is %s" % (self.basename, self.status)
            return
        os.remove(self.name)
        shutil.move(self.target, self.name)

    def __str__(self):
        return '%-18s %-s' % (self.name.split('/')[-1], self.status)


class Dotfiles(object):
    """A Dotfiles Repository."""

    __attrs__ = ['homedir', 'repository', 'prefix', \
            'ignore', 'externals', 'updatecmd']

    def __init__(self, **kwargs):

        # Map args from kwargs to instance-local variables
        map(lambda k, v: (k in self.__attrs__) and setattr(self, k, v),
                kwargs.iterkeys(), kwargs.itervalues())

        self._load()

    def _load(self):
        """Load each dotfile in the repository."""

        self.dotfiles = list()

        all_repofiles = os.listdir(self.repository)
        repofiles_to_symlink = set(all_repofiles)

        for pat in self.ignore:
            repofiles_to_symlink.difference_update(
                    fnmatch.filter(all_repofiles, pat))

        for dotfile in repofiles_to_symlink:
            self.dotfiles.append(Dotfile(dotfile[len(self.prefix):],
                os.path.join(self.repository, dotfile), self.homedir))

        for dotfile in self.externals.keys():
            self.dotfiles.append(Dotfile(dotfile,
                os.path.expanduser(self.externals[dotfile]),
                self.homedir))

    def _fqpn(self, dotfile):
        """Return the fully qualified path to a dotfile."""

        return os.path.join(self.repository,
                            self.prefix + os.path.basename(dotfile).strip('.'))

    def list(self, verbose=True):
        """List the contents of this repository."""

        for dotfile in sorted(self.dotfiles, key=lambda dotfile: dotfile.name):
            if dotfile.status or verbose:
                print dotfile

    def check(self):
        """List only unsynced and/or missing dotfiles."""

        self.list(verbose=False)

    def sync(self, force=False):

        """Synchronize this repository, creating and updating the necessary
        symbolic links."""

        for dotfile in self.dotfiles:
            dotfile.sync(force)

    def add(self, files):
        """Add dotfile(s) to the repository."""

        self._perform_action('add', files)

    def remove(self, files):
        """Remove dotfile(s) from the repository."""

        self._perform_action('remove', files)

    def _perform_action(self, action, files):
        for file in files:
            file = file.rstrip('/')
            if os.path.basename(file).startswith('.'):
                getattr(Dotfile(file, self._fqpn(file), \
                        self.homedir), action)()
            else:
                print "Skipping \"%s\", not a dotfile" % file

    def move(self, target):
        """Move the repository to another location."""

        if os.path.exists(target):
            raise ValueError('Target already exists: %s' % (target))

        shutil.copytree(self.repository, target)
        shutil.rmtree(self.repository)

        self.repository = target

        self._load()
        self.sync(force=True)

    def update(self):
        print self.repository, self.updatecmd
        for cmd in self.updatecmd.split('&&'):
            subprocess.call(cmd.split(), cwd=self.repository)
